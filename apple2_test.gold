package social

import (
	"fmt"
	"runtime"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

var (
	appletoken = "c827217806c5341d0a01030af6d3f02ea.0.rrsvz.Ku8vcChil4pEOD-R8SjeFQ"
	clientID   = "spiritchief.ios.FutureCalendar" //spiritchief.futurecalendar app ID
	teamID     = "U4U6P5K5V6"
	callback   = "https://api.futery.com/oauth/apple" //Callback URL
	keyID      = "PNQJHK8XJ7"                         //Key ID
	privateKey = `-----BEGIN PRIVATE KEY-----
MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQg2KMuEqqNi9BUHPXH
jpwQNIrHa/9A3P24WN0rwJrQ8N2gCgYIKoZIzj0DAQehRANCAAQxvqsU6L+GpyDl
PMT+lPybEMZwnBCbWd6rSK7r4Jngx6yRZQlI2+CzELPJqZ0KYgPgQrAf7Ih4Mxsp
4RlTmSMK
-----END PRIVATE KEY-----`  //p8

)

func Test2(ggggg *testing.T) {
	function, _, _, _ := runtime.Caller(0)
	fn := runtime.FuncForPC(function).Name()
	fn = fn[strings.LastIndex(fn, ".Test")+5:]
	fn = strings.Join(strings.Split(fn, "_"), ": ")
	fmt.Printf("\033[1;32m%s\033[0m\n", fn)

	a := assert.New(ggggg)
	_ = a

	u, err := Apple(appletoken, privateKey, teamID, clientID, keyID)
	a.Nil(err)
	fmt.Println(u.Email)
}

/*
func Test2(ggggg *testing.T) {
	function, _, _, _ := runtime.Caller(0)
	fn := runtime.FuncForPC(function).Name()
	fn = fn[strings.LastIndex(fn, ".Test")+5:]
	fn = strings.Join(strings.Split(fn, "_"), ": ")
	fmt.Printf("\033[1;32m%s\033[0m\n", fn)

	a := assert.New(ggggg)
	_ = a

	secret, err := apple.GenerateClientSecret(privateKey, teamID, clientID, keyID)
	if err != nil {
		fmt.Println("error generating secret: " + err.Error())
		return
	}

	// Generate a new validation client
	client := apple.New()

	vReq := apple.AppValidationTokenRequest{
		ClientID:     clientID,
		ClientSecret: secret,
		Code:         appletoken,
	}

	var resp apple.ValidationResponse

	// Do the verification
	err = client.VerifyAppToken(context.Background(), vReq, &resp)
	if err != nil {
		fmt.Println("error verifying: " + err.Error())
		return
	}

	if resp.Error != "" {
		fmt.Println("apple returned an error: " + resp.Error)
		return
	}

	// Get the unique user ID
	unique, err := apple.GetUniqueID(resp.IDToken)
	if err != nil {
		fmt.Println("failed to get unique ID: " + err.Error())
		return
	}

	// Get the email
	claim, err := apple.GetClaims(resp.IDToken)
	if err != nil {
		fmt.Println("failed to get claims: " + err.Error())
		return
	}

	email := (*claim)["email"]
	emailVerified := (*claim)["email_verified"]
	isPrivateEmail := (*claim)["is_private_email"]

	// Voila!
	fmt.Println(unique)
	fmt.Println(email)
	fmt.Println(emailVerified)
	fmt.Println(isPrivateEmail)

	select {}
}
*/
